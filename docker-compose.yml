version: "3.7" # Compose version. 3.7 is for docker engine 18.06.0+. 

# Compose file for production. dev environment overrides go in docker-dompose.override.yml
# TODO: might be better to have this be dev file and use overrides for production and staging?

services:
    couchdb:
        image: apache/couchdb:3
        volumes:
            # this is a named volume for database storage
            - couchdata:/opt/couchdb/data
            # host volume/bind mounts to map couchdb's config and logging to local directories
            # couch docker image creates docker.ini in local.d folder
            - ~/ff/couchmounts/config:/opt/couchdb/etc/local.d
            # must enable logging in config
            - ~/ff/couchmounts/logs:/opt/couchdb/log
        ports:
            - 5984:5984
        networks: # helps API talk to couch
            - backend
        # TODO: the couch image does not normally check files in /run/secrets/couch_admin, it only checks env vars,
        # must either set up admin and replicator manually, or write build file to add them to ini.
        # Orrr just use this to start, then change creds once it's running
        #environment: 
            #COUCHDB_USER: admin
            #COUCHDB_PASSWORD: password #specify this differently for committing
        #secrets: 
            #- couch_admin
            #- couch_password
            #- couch_replicator_user
            #- couch_replicator_password

    #ionic:
        #build: app/
        # not sure if need volumes, but what ports in container to map?
    api:
        image: ff-server
        # To build for prod, use export MY_SERVICE_VERSION=1.2.3, then docker-compose -f docker-compose.yml build,
        # then push. Could launch in prod (or staging) by exporting right vars, then using
        # docker stack deploy my-stack --compose-file docker-compose.yml --with-registry-auth
        # ^^^ for swarm mode
        # image: private.registry.mine/my-stack/my-service:${MY_SERVICE_VERSION:-latest}

        # Build context, this will be the base path for dockerfile. Can specify both context and file itself w/ context: and dockerfile:
        # TODO: for dev keep mounting code in volume. For prod, build code to the location where the dev-only volume is mounted.
        build: server/
        environment: # can also use a .env file
            COUCHDB_URL: 'couchdb:5984' #access with 'http://user:pass@couchdb:5984'
            FRONTEND_URL: 'http://localhost:8100'
        depends_on:
            - couchdb #specifies that couchdb spins up first
        links:
            - couchdb
        networks:
            - backend
        ports:
            - "3000:3000"
        volumes:
            # TODO: docker now supports watch syntax to copy over local files when changed or rebuild, supports ignores. Similar functionality to bind mounts. Looks cool.
            # --would be smart enough to recognize that a rebuild is needed when package.json changes, for example.
            - ./server:/usr/src/app #completely replaces whatever the image has in /usr/src/app
            # It's more than slightly insane to use symlinks in WSL, mounts inside container, and file copying for built image...
            # Could try moving build context to parent dir and excluding app files from copy so symlinks work inside container.
            # For production, turn bind mind volumes into normal ones? External volumes for swarm deploy?
            # No, code changes are supposed to mean rebuilding and redeploying image, and mounts can't be accessed during builds.
        secrets:
            - couch_admin
            - couch_password
            - couch_replicator_user
            - couch_replicator_password
            - mail_from_address
            - mail_api_key

    # TODO: should have another service to serve the frontent? For scalability yes.
    # But if using node+express for both frontend and API might not be an issue...
    # Either way production frontend needs env vars for addresses of db and api... or... same domain?
    # Whatever I do probably needs to interface with traefik for letsencrypt?
    # Should put couchdb AND discordbot behind reverse proxy too
    # JUST DO IT: https://medium.com/intrinsic-blog/why-should-i-use-a-reverse-proxy-if-node-js-is-production-ready-5a079408b2ca
    # But if nginx is my reverse proxy, do I need traefik??
    # ALSO node itself will be the one doing server-side rendering
    #frontend:


    # reverse proxy, letsencrypt. Dashboard at http://localhost:8080/dashboard#/
    # TODO: for prod, put dashboard behind IP whitelist, not exposed on public network or default port
    reverse-proxy:
        # The official v2 Traefik docker image
        image: traefik:v2.8
        # Enables the web UI and tells Traefik to listen to docker
        command: 
            - --api.insecure=true # when not in prod
            - --providers.docker=true
        #deploy: #this stuff is only used with 'docker stack deploy', ignored by docker compose
            #labels: 
        ports:
        # The HTTP port
        - "80:80"
        # The Web UI (enabled by --api.insecure=true)
        - "8080:8080"
        volumes:
        # So that Traefik can listen to the Docker events
        - /var/run/docker.sock:/var/run/docker.sock
    whoami:
        # A container that exposes an API to show its IP address
        image: traefik/whoami
        labels:
        - "traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)"

volumes:
    couchdata:
    # Make this read-only for api
    #shared:

networks:
  backend:
    driver: bridge

secrets: # available in containers in /run/secrets/secret_name. Long notation can set file perms.
    couch_admin:
        file: ./secrets/couch_admin.txt
    couch_password:
        file: ./secrets/couch_password.txt
    couch_replicator_user:
        file: ./secrets/couch_replicator_user.txt
    couch_replicator_password:
        file: ./secrets/couch_replicator_password.txt
    mail_from_address:
        file: ./secrets/mail_from_address_test.txt
    mail_api_key:
        file: ./secrets/mail_api_key_test.txt
    #mail_from_address_test:
        #file: ./secrets/mail_from_address_test.txt
    #mail_api_key_test:
        #file: ./secrets/mail_api_key_test.txt
